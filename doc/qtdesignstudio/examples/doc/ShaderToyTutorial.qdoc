// Copyright (C) 2025 The Qt Company Ltd.
// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR GFDL-1.3-no-invariants-only

/*!
    \page effect-composer-shadertoy.html
    \previouspage qtquick-transition-editor.html
    \nextpage qtquick-curve-editor.html

    \sa {Effect Composer}

    \title Using a shader from Shadertoy in effect compositions

    \brief Copy the Moving bars shader code from Shadertoy and use it in your
    effect compositions.

    This tutorial describes how you can use a shader from
    \l{https://shadertoy.com}{Shadertoy} to create a custom effect to use in the
    \QDS \uicontrol {Effect Composer}.

    To create the custom effect, you will use the \e {Moving bars} shader code:

    \code
            const float pi = 3.14159265;

            vec3 blurry_rectangle(vec2 p, float xEdgeWidth, float yEdgeWidth, float xBlurriness, float yBlurriness, float xOffset, float yOffset) {
            // the blurry rectangle mask
            p -= vec2(xOffset, yOffset);
            float smoothFrequency = 1.0;
            vec2 innerEdge = vec2(xEdgeWidth, yEdgeWidth) - vec2(xBlurriness, yBlurriness);
            vec2 outerEdge = vec2(xEdgeWidth, yEdgeWidth) + vec2(xBlurriness, yBlurriness);
            vec2 bl = smoothstep(innerEdge, outerEdge, p); // bottom-left
            vec2 tr = smoothstep(innerEdge, outerEdge, 1.0 - p); // top-right
            return vec3(bl.x * bl.y * tr.x * tr.y);
            }

            vec3 waves(vec2 p, float xWiggleRate, float yWiggleRate, float xFrequency, float yFrequency, float xWiggle, float yWiggle) {
            xFrequency += sin(iTime * xWiggleRate);
            yFrequency += sin(iTime * yWiggleRate);
            return vec3(cos(xFrequency * (p.x + xWiggle * sin(p.y))) * cos(yFrequency * (p.y + yWiggle * cos(p.y))));
            }

            float glow(vec2 p) {
            vec2 pn = p * 2.0 - 1.0;
            
            float glowScalar = 2.0;
            float glowAdder = 0.0;
            
            float fadeFrequency = 1.0;
            float glowColor = glowAdder + (1.0 - length(pn)) * glowScalar - (0.5 * sin(fadeFrequency * iTime) + 0.5);
            return clamp(glowColor, 0.0, 1.0);
            }

            float sinSpeeding(float position, float offset) {
            float speed = 100.0 * smoothstep(3.0, 100.0, position);
            return sin(0.01 * position * speed + offset);
            }

            void mainImage( out vec4 fragColor, in vec2 fragCoord )
            {
            // position on screen
            vec2 p = fragCoord.xy / iResolution.xy;
            
            // rectangle masks
            vec3 mask1 = blurry_rectangle(p, 0.4, 0.125, 0.02, 0.02, 0.3 * sinSpeeding(iTime, 0.0), 0.0);
            vec3 mask2 = blurry_rectangle(p, 0.4, 0.125, 0.02, 0.02, 0.3 * sinSpeeding(iTime, 2.0 * pi / 3.0), 0.0);
            vec3 mask3 = blurry_rectangle(p, 0.4, 0.125, 0.02, 0.02, 0.3 * sinSpeeding(iTime, 4.0 * pi / 3.0), 0.0);
            
            // inside the blurry rectangle
            vec3 color1 = waves(p, 0.2, 0.2, 10.0, 10.0, 5.0, 5.0);
            vec3 color2 = waves(p, 0.1, 0.1, 2.0, 1.0, 100.0, 5.0);
            vec3 color3 = waves(p, 0.1, 0.1, 2.0, 5.0, 1.0, 5.0);
            
            float glowVal = glow(p);
            fragColor = vec4(mask1 * color1 + mask2 * color2 + mask3 * color3, 1.0) * vec4(0.8 * glowVal, 0.2 * glowVal, 1.0, 1.0);
            }
    \endcode

    \section1 Adding a new custom effect for the shader

    First, you need to add a new custom effect to your composition. Later, you will copy the
    shader code to this custom effect.

    To add a custom effect to your composition, select \uicontrol {Add Effect},
    and then select \uicontrol Custom.

    \image add-custom-effect-node.webp Adding a custom effect to an effect composition.

    \section1 Copying the shader code to Shaders Code Editor

    Next, you will open copy the shader code and paste it to \uicontrol {Fragment Shader} 
    tab of \uicontrol {Shaders Code Editor}:

    \list 1
        \li Select \imageadvancedCodeView to enable the advanced mode.
        \li Select \uicontrol {Show Code}.
        \li Copy the functions of the shader and paste them to above the \c {@main} function:
            \code
            float rand(vec2 co){
            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
            }

            float hermite(float t)
            {
            return t * t * (3.0 - 2.0 * t);
            }

            float noise(vec2 co, float frequency)
            {
            vec2 v = vec2(co.x * frequency, co.y * frequency);

            float ix1 = floor(v.x);
            float iy1 = floor(v.y);
            float ix2 = floor(v.x + 1.0);
            float iy2 = floor(v.y + 1.0);

            float fx = hermite(fract(v.x));
            float fy = hermite(fract(v.y));

            float fade1 = mix(rand(vec2(ix1, iy1)), rand(vec2(ix2, iy1)), fx);
            float fade2 = mix(rand(vec2(ix1, iy2)), rand(vec2(ix2, iy2)), fx);

            return mix(fade1, fade2, fy);
            }

            float pnoise(vec2 co, float freq, int steps, float persistence)
            {
            float value = 0.0;
            float ampl = 1.0;
            float sum = 0.0;
            for(int i=0 ; i<steps ; i++)
            {
                sum += ampl;
                value += noise(co, freq) * ampl;
                freq *= 2.0;
                ampl *= persistence;
            }
            return value / sum;
            }

            @main
            {
            }
            \endcode
        \li Copy the code inside \c {void mainImage( out vec4 fragColor, in vec2 fragCoord )}
            and paste it inside the \c {@main} function:
            \code
            float rand(vec2 co){
            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
            }

            float hermite(float t)
            {
            return t * t * (3.0 - 2.0 * t);
            }

            float noise(vec2 co, float frequency)
            {
            vec2 v = vec2(co.x * frequency, co.y * frequency);

            float ix1 = floor(v.x);
            float iy1 = floor(v.y);
            float ix2 = floor(v.x + 1.0);
            float iy2 = floor(v.y + 1.0);

            float fx = hermite(fract(v.x));
            float fy = hermite(fract(v.y));

            float fade1 = mix(rand(vec2(ix1, iy1)), rand(vec2(ix2, iy1)), fx);
            float fade2 = mix(rand(vec2(ix1, iy2)), rand(vec2(ix2, iy2)), fx);

            return mix(fade1, fade2, fy);
            }

            float pnoise(vec2 co, float freq, int steps, float persistence)
            {
            float value = 0.0;
            float ampl = 1.0;
            float sum = 0.0;
            for(int i=0 ; i<steps ; i++)
            {
                sum += ampl;
                value += noise(co, freq) * ampl;
                freq *= 2.0;
                ampl *= persistence;
            }
            return value / sum;
            }


            @main
            {
                void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
                    vec2 uv = fragCoord.xy / iResolution.xy;
                    float gradient = 1.0 - uv.y;
                    float gradientStep = 0.2;
                    
                    vec2 pos = fragCoord.xy / iResolution.x;
                    pos.y -= iTime * 0.3125;
                    
                    vec4 brighterColor = vec4(1.0, 0.65, 0.1, 0.25);
                    vec4 darkerColor = vec4(1.0, 0.0, 0.15, 0.0625);
                    vec4 middleColor = mix(brighterColor, darkerColor, 0.5);
                
                    float noiseTexel = pnoise(pos, 10.0, 5, 0.5);
                    
                    float firstStep = smoothstep(0.0, noiseTexel, gradient);
                    float darkerColorStep = smoothstep(0.0, noiseTexel, gradient - gradientStep);
                    float darkerColorPath = firstStep - darkerColorStep;
                    vec4 color = mix(brighterColor, darkerColor, darkerColorPath);
                
                    float middleColorStep = smoothstep(0.0, noiseTexel, gradient - 0.2 * 2.0);
                    
                    color = mix(color, middleColor, darkerColorStep - middleColorStep);
                    color = mix(vec4(0.0), color, firstStep);
                    fragColor = color;
                }
            }
            \endcode
    \endlist

    You should now see the effect in the preview window in the \uicontrol {Effect Composer} view.
    If you don't see the effect, ensure that \uicontrol {Live Update} is selected.

    \image moving-bars-shaders-code-editor.webp The Moving bars shader in Effect Composer
    
    Select \imagerunproject to run the animation in the preview window.

    \section1 Using the the new effect composition in your project

    Next, you will save your effect composition with the new custom effect and assign it
    to a component.

    To save your effect composition, select \imagesaveeffectcomposer. If the composition
    is still \e Untitled, name it, and then select \uicontrol Save.

    To assign your newly created effect composition to a component, do one of the following:

    \list
        \li Select a component in \uicontrol Navigator or the \uicontrol 2D view,
            and then select \imageassigneffectcomposer in
            \uicontrol {Effect Composer}.
        \li Drag the composition from \uicontrol Assets to the component in
            \uicontrol Navigator or the \uicontrol {2D} view.
    \endlist
*/
